<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Cyber Seeds — Household Orientation</title>
<meta name="description" content="A calm, interactive 3D orientation of your household’s digital environment. No judgement. No monitoring. Just clarity." />

<link rel="canonical" href="https://cyberseeds-uk.github.io/contact/" />
<link rel="stylesheet" href="/style.css" />

<meta property="og:title" content="Cyber Seeds — Household Orientation" />
<meta property="og:description" content="A calm way to see how your digital home fits together." />
<meta property="og:image" content="/cyber_seeds_logo.png" />
<meta property="og:url" content="https://cyberseeds-uk.github.io/contact/" />
</head>

<body>

<!-- NAVBAR -->
<nav class="navbar">
  <div class="nav-container">
    <a href="/" class="nav-logo">
      <img src="/cyber_seeds_logo.png" alt="Cyber Seeds Logo">
      Cyber Seeds
    </a>

    <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">
      <span></span><span></span><span></span>
    </button>

    <ul class="nav-links" id="navLinks">
      <li><a href="/">Home</a></li>
      <li><a href="/about/">About</a></li>
      <li><a href="/services/">Services</a></li>
      <li><a href="/resources/">Resources</a></li>
      <li><a href="/schedule/">Next Steps</a></li>
      <li><a class="active" href="/contact/">Orientation</a></li>
    </ul>
  </div>
</nav>

<!-- HERO -->
<section class="cs-orient-hero">
  <div class="cs-orient-hero-inner">
    <h1>Your Household, Gently Mapped</h1>
    <p>
      Explore a calm 3D model of how a home connects digitally.
      Nothing here monitors anyone. This is simply an orientation — so you’re not navigating blind.
    </p>
  </div>
</section>

<!-- 3D STAGE -->
<section class="cs-orient-stage">
  <div class="cs-orient-frame">
    <div id="cs3d" class="cs-orient-canvas" aria-label="Cyber Seeds 3D orientation model"></div>

    <!-- Overlay UI -->
    <div class="cs-orient-ui">
      <div class="cs-orient-chip">Drag to rotate · Pinch/scroll to zoom</div>
      <button id="csReset" class="cs-orient-btn" type="button">Reset view</button>
    </div>

    <!-- Fallback -->
    <div id="csFallback" class="cs-orient-fallback" hidden>
      <h3>3D view unavailable</h3>
      <p>
        Your browser is blocking WebGL. Try opening this page in Safari/Chrome,
        or disable Low Power Mode / content blockers for this site.
      </p>
    </div>
  </div>

  <div class="cs-orient-caption">
    <div class="cs-orient-card">
      <p>
        Every household already has a digital shape: devices, accounts, habits, and people —
        interacting quietly in the background.
      </p>
      <p>
        Cyber Seeds makes that invisible structure visible, calmly and without judgement.
      </p>
      <p class="cs-orient-quiet">
        You don’t need to act yet. Understanding comes first.
      </p>
    </div>
  </div>
</section>

<footer>
  <p>© 2025 Cyber Seeds — Household Digital Clarity</p>
</footer>

<script>
document.getElementById("navToggle").addEventListener("click", () => {
  document.getElementById("navLinks").classList.toggle("open");
});
</script>

<!-- ✅ PRO WORKING 3D (ES MODULES) -->
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js";

/* --- WebGL support check --- */
function webglAvailable() {
  try {
    const canvas = document.createElement("canvas");
    return !!(window.WebGLRenderingContext &&
      (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
  } catch {
    return false;
  }
}

const container = document.getElementById("cs3d");
const fallback = document.getElementById("csFallback");
if (!webglAvailable()) {
  fallback.hidden = false;
  throw new Error("WebGL not available");
}

/* --- Renderer --- */
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

/* --- Scene --- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x020617, 8, 26);

/* --- Camera --- */
const camera = new THREE.PerspectiveCamera(
  55,
  container.clientWidth / container.clientHeight,
  0.1,
  100
);
camera.position.set(0, 3.2, 10);

/* --- Controls (damped, gentle) --- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.55;
controls.zoomSpeed = 0.8;
controls.minDistance = 6.2;
controls.maxDistance = 16;
controls.maxPolarAngle = Math.PI * 0.55; // prevents flipping below “floor”

/* --- Lighting (soft studio) --- */
scene.add(new THREE.AmbientLight(0xffffff, 0.55));

const key = new THREE.DirectionalLight(0x9bd3ff, 0.85);
key.position.set(6, 8, 6);
scene.add(key);

const fill = new THREE.DirectionalLight(0xb9ffd8, 0.35);
fill.position.set(-6, 4, -4);
scene.add(fill);

const rim = new THREE.PointLight(0xa78bfa, 0.35, 40);
rim.position.set(0, 6, -10);
scene.add(rim);

/* --- Materials (premium, calm) --- */
function glass(color, opacity=0.92) {
  return new THREE.MeshPhysicalMaterial({
    color,
    roughness: 0.28,
    metalness: 0.05,
    transmission: 0.35,
    thickness: 0.8,
    transparent: true,
    opacity,
    clearcoat: 0.8,
    clearcoatRoughness: 0.35
  });
}
const matInternet = new THREE.MeshStandardMaterial({
  color: 0x1e293b,
  transparent: true,
  opacity: 0.12,
  roughness: 0.9,
  metalness: 0.0
});

/* --- Backdrop (subtle star-dust) --- */
const dustGeo = new THREE.BufferGeometry();
const dustCount = 900;
const dustPos = new Float32Array(dustCount * 3);
for (let i = 0; i < dustCount; i++) {
  const r = 18 * Math.cbrt(Math.random());
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  dustPos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
  dustPos[i*3+1] = (r * Math.cos(phi)) * 0.55;
  dustPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
}
dustGeo.setAttribute("position", new THREE.BufferAttribute(dustPos, 3));
const dustMat = new THREE.PointsMaterial({ size: 0.02, opacity: 0.55, transparent: true });
const dust = new THREE.Points(dustGeo, dustMat);
scene.add(dust);

/* --- Core structure --- */
const group = new THREE.Group();
scene.add(group);

/* Outer “Internet” shell */
const internet = new THREE.Mesh(new THREE.SphereGeometry(6.2, 48, 48), matInternet);
group.add(internet);

/* Gateway (router, but not labelled loudly) */
const gateway = new THREE.Mesh(new THREE.IcosahedronGeometry(0.62, 2), glass(0x38bdf8));
gateway.position.set(0, 0.2, 0.2);
group.add(gateway);

/* Zones */
const adult = new THREE.Mesh(new THREE.SphereGeometry(0.95, 40, 40), glass(0xa78bfa));
adult.position.set(-2.4, 0.0, 0.4);

const shared = new THREE.Mesh(new THREE.SphereGeometry(0.95, 40, 40), glass(0x34d399));
shared.position.set(0.0, 0.0, -2.2);

const child = new THREE.Mesh(new THREE.SphereGeometry(0.95, 40, 40), glass(0xfbbf24));
child.position.set(2.4, 0.0, 0.4);

group.add(adult, shared, child);

/* Household Signal (breathing core) */
const signal = new THREE.Mesh(new THREE.SphereGeometry(0.38, 40, 40), glass(0xffffff, 0.96));
signal.position.set(0, -0.15, 0);
group.add(signal);

/* Connection threads */
const threadMat = new THREE.LineBasicMaterial({ transparent: true, opacity: 0.22 });
function thread(a, b) {
  const geo = new THREE.BufferGeometry().setFromPoints([a, b]);
  return new THREE.Line(geo, threadMat);
}
group.add(thread(gateway.position, adult.position));
group.add(thread(gateway.position, shared.position));
group.add(thread(gateway.position, child.position));
group.add(thread(adult.position, signal.position));
group.add(thread(shared.position, signal.position));
group.add(thread(child.position, signal.position));

/* Ground plane (very subtle) */
const plane = new THREE.Mesh(
  new THREE.CircleGeometry(7.2, 64),
  new THREE.MeshStandardMaterial({ color: 0x0b1220, transparent: true, opacity: 0.35, roughness: 1 })
);
plane.rotation.x = -Math.PI / 2;
plane.position.y = -1.25;
group.add(plane);

/* --- Animation (calm, premium) --- */
let t = 0;
function animate() {
  t += 0.007;

  // gentle breathing
  const breath = 1 + Math.sin(performance.now() * 0.002) * 0.06;
  signal.scale.set(breath, breath, breath);

  // slow ambient drift
  adult.position.y = Math.sin(t * 1.2) * 0.08;
  shared.position.y = Math.sin(t * 1.1 + 1.8) * 0.08;
  child.position.y = Math.sin(t * 1.25 + 3.2) * 0.08;
  gateway.rotation.y += 0.004;

  // dust drift
  dust.rotation.y += 0.0008;

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* --- Resize --- */
function onResize() {
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener("resize", onResize);

/* --- Reset view button --- */
document.getElementById("csReset").addEventListener("click", () => {
  camera.position.set(0, 3.2, 10);
  controls.target.set(0, 0, 0);
  controls.update();
});
</script>

</body>
</html>
